/*
Navicat MySQL Data Transfer

Source Server         : mytest
Source Server Version : 50722
Source Host           : 192.168.139.130:3306
Source Database       : paper_manage

Target Server Type    : MYSQL
Target Server Version : 50722
File Encoding         : 65001

Date: 2018-06-15 09:48:31
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for tb_log_check_paper
-- ----------------------------
DROP TABLE IF EXISTS `tb_log_check_paper`;
CREATE TABLE `tb_log_check_paper` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `paperId` bigint(20) NOT NULL,
  `checkUserId` bigint(20) NOT NULL,
  `updatedState` varchar(20) CHARACTER SET utf8 DEFAULT NULL,
  `createdtime` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=72 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of tb_log_check_paper
-- ----------------------------
INSERT INTO `tb_log_check_paper` VALUES ('71', '24', '2', '审核通过', '2018-06-15 09:44:43');

-- ----------------------------
-- Table structure for tb_paper
-- ----------------------------
DROP TABLE IF EXISTS `tb_paper`;
CREATE TABLE `tb_paper` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(100) NOT NULL,
  `createdtime` datetime DEFAULT NULL,
  `updatedtime` datetime DEFAULT NULL,
  `content` text,
  `userId` bigint(20) DEFAULT NULL,
  `read_num` int(11) DEFAULT NULL,
  `state` varchar(20) DEFAULT NULL,
  `typeid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tb_paper
-- ----------------------------
INSERT INTO `tb_paper` VALUES ('24', 'oracle查询重复数据方法', '2018-06-15 09:15:12', null, '<p class=\"ql-align-justify\"><strong>SQL重复记录查询</strong></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><strong>1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</strong></p><p class=\"ql-align-justify\">select * from people</p><p class=\"ql-align-justify\">where peopleId in (select&nbsp;&nbsp;peopleId from&nbsp;&nbsp;people group by&nbsp;&nbsp;peopleId having count</p><p class=\"ql-align-justify\">(peopleId) &gt; 1)</p><p class=\"ql-align-justify\"><strong>2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录</strong></p><p class=\"ql-align-justify\">delete from people&nbsp;</p><p class=\"ql-align-justify\">where peopleId in (select&nbsp;&nbsp;peopleId from people group by&nbsp;&nbsp;peopleId&nbsp;&nbsp;having count</p><p class=\"ql-align-justify\">(peopleId) &gt; 1)</p><p class=\"ql-align-justify\">and rowid not in (select min(rowid) from&nbsp;&nbsp;people group by peopleId having count(peopleId</p><p class=\"ql-align-justify\">)&gt;1)</p><p class=\"ql-align-justify\"><strong>3、查找表中多余的重复记录（多个字段）</strong>&nbsp;</p><p class=\"ql-align-justify\">select * from vitae a</p><p class=\"ql-align-justify\">where (a.peopleId,a.seq) in&nbsp;&nbsp;(select peopleId,seq from vitae group by peopleId,seq having</p><p class=\"ql-align-justify\">count(*) &gt; 1)</p><p class=\"ql-align-justify\"><strong>4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录</strong></p><p class=\"ql-align-justify\">delete from vitae a</p><p class=\"ql-align-justify\">where (a.peopleId,a.seq) in&nbsp;&nbsp;(select peopleId,seq from vitae group by peopleId,seq having</p><p class=\"ql-align-justify\">count(*) &gt; 1)</p><p class=\"ql-align-justify\">and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1)</p><p class=\"ql-align-justify\"><strong>5、查找表中多余的重复记录（多个字段），不包含rowid最小的记录</strong></p><p class=\"ql-align-justify\">select * from vitae a</p><p class=\"ql-align-justify\">where (a.peopleId,a.seq) in&nbsp;&nbsp;(select peopleId,seq from vitae group by peopleId,seq having</p><p class=\"ql-align-justify\">count(*) &gt; 1)</p><p class=\"ql-align-justify\">and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1)</p><p class=\"ql-align-justify\"><strong>(二)</strong></p><p class=\"ql-align-justify\"><strong>比方说</strong></p><p class=\"ql-align-justify\"><strong>在A表中存在一个字段“name”，</strong></p><p class=\"ql-align-justify\"><strong>而且不同记录之间的“name”值有可能会相同，</strong></p><p class=\"ql-align-justify\"><strong>现在就是需要查询出在该表中的各记录之间，“name”值存在重复的项；</strong></p><p class=\"ql-align-justify\">Select Name,Count(*) From A Group By Name Having Count(*) &gt; 1</p><p class=\"ql-align-justify\"><strong>如果还查性别也相同大则如下:</strong></p><p class=\"ql-align-justify\">Select Name,sex,Count(*) From A Group By Name,sex Having Count(*) &gt; 1</p><p class=\"ql-align-justify\"><strong>(三)</strong></p><p class=\"ql-align-justify\"><strong>方法一</strong></p><p class=\"ql-align-justify\">declare @max integer,@id integer</p><p class=\"ql-align-justify\">declare cur_rows cursor local for select&nbsp;主字段,count(*) from&nbsp;表名 group by 主字段 having</p><p class=\"ql-align-justify\">count(*) &gt;； 1</p><p class=\"ql-align-justify\">open cur_rows</p><p class=\"ql-align-justify\">fetch cur_rows into @id,@max</p><p class=\"ql-align-justify\">while @@fetch_status=0</p><p class=\"ql-align-justify\">begin</p><p class=\"ql-align-justify\">select @max = @max -1</p><p class=\"ql-align-justify\">set rowcount @max</p><p class=\"ql-align-justify\">delete from&nbsp;表名 where 主字段 = @id</p><p class=\"ql-align-justify\">fetch cur_rows into @id,@max</p><p class=\"ql-align-justify\">end</p><p class=\"ql-align-justify\">close cur_rows</p><p class=\"ql-align-justify\">set rowcount 0</p><p class=\"ql-align-justify\"><strong> 方法二</strong></p><p class=\"ql-align-justify\"><strong> 有两个意义上的重复记录，一是完全重复的记录，也即所有字段均重复的记录，二是部分关键字段重</strong></p><p class=\"ql-align-justify\"><strong>复的记录，比如Name字段重复，而其他字段不一定重复或都重复可以忽略。</strong></p><p class=\"ql-align-justify\"><strong> 1、对于第一种重复，比较容易解决，使用</strong></p><p class=\"ql-align-justify\">select distinct * from tableName</p><p class=\"ql-align-justify\"><strong> 就可以得到无重复记录的结果集。</strong></p><p class=\"ql-align-justify\"><strong> 如果该表需要删除重复的记录（重复记录保留1条），可以按以下方法删除</strong></p><p class=\"ql-align-justify\">select distinct * into #Tmp from tableName</p><p class=\"ql-align-justify\">drop table tableName</p><p class=\"ql-align-justify\">select * into tableName from #Tmp</p><p class=\"ql-align-justify\">drop table #Tmp</p><p class=\"ql-align-justify\"><strong> 发生这种重复的原因是表设计不周产生的，增加唯一索引列即可解决。</strong></p><p class=\"ql-align-justify\"><strong> 2、这类重复问题通常要求保留重复记录中的第一条记录，操作方法如下</strong></p><p class=\"ql-align-justify\">假设有重复的字段为Name,Address，要求得到这两个字段唯一的结果集</p><p class=\"ql-align-justify\">select identity(int,1,1) as autoID, * into #Tmp from tableName</p><p class=\"ql-align-justify\">select min(autoID) as autoID into #Tmp2 from #Tmp group by Name,autoID</p><p class=\"ql-align-justify\">select * from #Tmp where autoID in(select autoID from #tmp2)</p><p class=\"ql-align-justify\"><strong> 最后一个select即得到了Name，Address不重复的结果集（但多了一个autoID字段，实际写时可以写</strong></p><p class=\"ql-align-justify\"><strong>在select子句中省去此列）</strong></p><p class=\"ql-align-justify\"><strong>(四)查询重复</strong></p><p class=\"ql-align-justify\">select * from tablename where id in (</p><p class=\"ql-align-justify\">select id from tablename&nbsp;</p><p class=\"ql-align-justify\">group by id&nbsp;</p><p class=\"ql-align-justify\">having count(id) &gt; 1</p><p class=\"ql-align-justify\">)</p><p><br></p>', '1', '5', '审核通过', '1');
INSERT INTO `tb_paper` VALUES ('25', ' 一位Java工程师的阶段性工作总结', '2018-06-15 09:17:48', null, '<p class=\"ql-align-justify\"><strong style=\"color: rgb(249, 3, 21);\">一、技术积累</strong></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><strong>（1）代码规范</strong></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">1.1.1、通常的模块分布：一般如果你要实现一个web应用，你从后台将数据展示到前端页面，在一个比较大的公司，你少不了跟其他项目有交集（你调用他的接口，他依赖你的接口），这样下来，整个公司有很多个模块，怎么做到很好的联系。回到刚刚的模块分布，你的一个web应用，应当需要分成三个模块：core模块、service模块、web模块。web模块就是展示到页面，后台代码而言主要就controller层了，其他逻辑基本都放在core了，service模块就是一些接口类和参数dto等等，接口的实现类在core模块。这样下来，web模块只需要依赖service模块，同样的其他系统依赖你的接口也仅仅是依赖service模块，然后利用远程调用方式消费你的接口服务。</p><p class=\"ql-align-justify\">1.1.2、代码层级结构：针对后台服务项目，一般分为对外接口层、service层、Dao层。Dao层就是与数据库交接的接口层，service层主要调用Dao或者外部系统的接口，复杂的逻辑基本都放在service层；一些方法需要提供给其他模块调用的时候，就封装在对外接口层，只有对外接口层是暴露。这里说的只是层级结构，还有与层级结构无关的，也是需要归类的，比如对外部系统接口方法封装的我们放在一个目录下面，一些常量和工具类等我们放在common目录下面。当然还有其他考虑，尽量让整个模块有层次感，代码才不会太乱，更好的维护。</p><p class=\"ql-align-justify\">1.1.3、总结上面两点：可能不少猿友觉得上面啰嗦又不像代码规范，其实这两点也是代码规范的一部分，主要引导大家往结构清晰好维护的思维方向走，多思考吧。</p><p class=\"ql-align-justify\">1.1.4、对于一些需要异步处理的，不要直接new一个thread，应当使用线程池。使用线程池的时候应当对线程数量大小合理设置，一般最大不超过50个，当然还需要考虑你的IO和CPU，怎么分析网上搜搜吧。</p><p class=\"ql-align-justify\">1.1.5、容器类变量，如果变化比较大且频繁，尽量定义的时候设置初始容量大小，减少扩容带来的消耗。</p><p class=\"ql-align-justify\">1.1.6、分支判断if…else的时候，最常符合的条件处理放在前面。</p><p class=\"ql-align-justify\">1.1.7、对象比较的时候常量放前面，养成好习惯，减少空指针的出现。</p><p class=\"ql-align-justify\">1.1.8、减少synchronized中等待处理的代码，能放在外面就尽量放在外面。</p><p class=\"ql-align-justify\">1.1.9、下面到数据库了，我觉得还是在这里说了好点，一般查询比较慢，很有可能是没有建索引或者索引没用到，多去检查一下。</p><p class=\"ql-align-justify\">1.1.10、两个大表的关联查询，可以使用二次访问数据库替代，先查出A表的数据，利用关联字段再查B表的。不要一味想着一条sql搞定最好。</p><p class=\"ql-align-justify\">1.1.11、坚决避免，查全表数据或者数量大的数据，返回list加载到内存中，一不小心查了100w数据，又查得比较频繁，内存的爆了。有这种风险的改成分页查询。</p><p class=\"ql-align-justify\">1.1.12、不要select *，按需取列。</p><p class=\"ql-align-justify\">1.1.13、多考虑避免事务里面有长连接或者长事务，如果大量这种情况出现占用数据连接，会影响性能。一些无必要的逻辑可以放到事务外执行。</p><p class=\"ql-align-justify\">1.1.14、对字段的加减乘除处理放到sql，严格避免先get处理，然后运算在set到数据库里面，并发情况非常容易导致失真。</p><p class=\"ql-align-justify\">1.1.15、方法里面代码不要太长，注意封装，命名语义化，代码整洁。常挂嘴边的，没放心上，一如既往的给自己埋坑，举个博主的例子，那会刚毕业也是没放心上，最近把我们组长不写代码，一到代码评审我就害怕，检视到有问题的代码，毕业生吧就说这代码以前就是这样写的，问题最终肯定都落我身上，现在感觉代码是自己的孩子，只能有空自己偷偷的优化一下，怕出问题还得非常仔细。</p><p class=\"ql-align-justify\"><strong>（2）SQL规范与性能优化</strong></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">1.2.1、先提前声明，博主工作用到是MySQL，可能有些场景只针对MySQL。说到SQL优化，一些概念必须要理解，不然死记硬背一两天就忘记了。特别是执行计划的概念。</p><p class=\"ql-align-justify\">1.2.2、什么是执行计划：a.决定如何访问表数据，是否通过索引，是否排序等。b.多表关联是先访问哪个表。c.多表关联时，使用哪种连接方式，不过现在MySQL只有嵌套连接（嵌套循环，顾名思义就是将一个表为出发点，将该表全部记录逐条去遍历另外一张表的记录）。</p><p class=\"ql-align-justify\">1.2.3、SQL执行顺序：a.检查语法是否正确。b.检查表是否存在、权限是否满足等。c.根据统计信息(如data length,rows,index length、索引唯一度)，生成较优的执行计划。d.根据执行计划，进行数据检索、过滤、合并、排序等操作。访问数据时，内存中如存在表数据，则直接进行操作；否则，从磁带读取表数据，放入内存，再进行操作；如内存不足，则内存中较冷数据涮出内存，再从内存中读取数据。</p><p class=\"ql-align-justify\">1.2.4、索引：查询的时候如果使用上了索引，可以提高效率，因为建立了索引后，可以理解为数据字典的结构存储，因此根据条件查询的时候更加高效。下面看一下MySQL常用的索引类型的概念。&nbsp;</p><p class=\"ql-align-justify\">a．普通索引：在创建普通索引时，不附加任何限制条件。这类索引可以创建在任何数据类型中，其值是否唯一和非空由字段本身的完整性约束条件决定。建立索引以后，查询时可以通过索引进行查询。例如，在student表的stu_id字段上建立一个普通索引。查询记录时，就可以根据该索引进行查询。</p><p class=\"ql-align-justify\">b．唯一性索引:使用UNIQUE参数可以设置索引为唯一性索引。在创建唯一性索引时，限制该索引的值必须是唯一的。例如，在student表的stu_name字段中创建唯一性索引，那么stu_name字段的值就必需是唯一的。通过唯一性索引，可以更快速地确定某条记录。主键就是一种特殊唯一性索引。</p><p class=\"ql-align-justify\">c．单列索引:在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段 即可。</p><p class=\"ql-align-justify\">d．多列索引：多列索引是在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询。但是，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用。例如，在表中的id、name和sex字段上建立一个多列索引，那么，只有查询条件使用了id字段时该索引才会被使用。</p><p class=\"ql-align-justify\">e . 全文索引：使用FULLTEXT参数可以设置索引为全文索引。全文索引只能创建在CHAR、VARCHAR或TEXT类型的字段上。查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，student表的information字段是TEXT类型，该字段包含了很多的文字信息。在information字段上建立全文索引后，可以提高查询information字段的速度。MySQL数据库从3.23.23版开始支持全文索引，但只有MyISAM存储引擎支持全文检索。在默认情况下，全文索引的搜索执行方式不区分大小写。但索引的列使用二进制排序后，可以执行区分大小写的全文索引。</p><p class=\"ql-align-justify\">还有空间索引，平时也比较少用。目前只有MyISAM存储引擎支持空间检索。目前博主也只接触过InnoDB存储引擎。</p><p class=\"ql-align-justify\">1.2.5、一般一张表索引不要超过5个，而且避免重复索引，而且也不是建了索引，根据索引字段条件查询，索引就会起作用。</p><p class=\"ql-align-justify\">1.2.6、一般哪些场景会导致索引失效：a.使用like关键字匹配字符串第一个为”%”的场景。b.条件中包含or、in、not in、&lt;&gt;关键字，默认不走索引的。c.访问表上的数据行超出表总记录数30%，变成全表扫描。d.查询条件使用函数在索引列上，或者对索引列进行运算。e.多列索引中，第一个索引列使用范围查询，只能用到部份或无法使用索引。f.多列索引中，第一个查询条件不是最左索引列，上面多列索引概念中也有提到。肯定还有更多的场景，但是博主现在能想到的场景就这些了。</p><p class=\"ql-align-justify\">1.2.7、不能同时使用两个索引，一个过滤数据，一个用于排序（主键除外）。</p><p class=\"ql-align-justify\">1.2.8、DML语句如果使用索引，会导致lock全表；如果使用了非唯一索引，可能只是锁住一定范围。对此，建议更新/删除数据尽量用上索引，如果可以最好用上主键或唯一索引，另外事务要及时提交。</p><p class=\"ql-align-justify\">1.2.9、最后一点，如何看执行计划，分析SQL的性能。这个吧，三言两语说不清楚，直接看其他博主的博文吧：<span style=\"color: rgb(2, 30, 170);\">http://www.cnblogs.com/xiaoboluo768/p/5400990.html</span>。一定要看！！！</p><p class=\"ql-align-justify\"><strong>（3）关于事务的一些建议</strong></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">如果没有听过事务这么个概念，网上了解学习一下，先理解一下各个事务类型的含义吧：a.日志记录尽量放在独立事务里面，避免后面的异常发生导致日志丢失。b.上面已经几次提到，尽早提交事务，避免事务过长，因此写代码的时候，一些可以不放到事务的逻辑可以移到外面，长事务看能否拆成两个事务。</p><p class=\"ql-align-justify\"><strong>（4）关于数据库连接池</strong></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">可能一些猿友都少去注意吧。先来看看一些参数，这里只罗列了博主比较关注的，更多的可以自行查看一下配置。&nbsp;</p><p class=\"ql-align-justify\">initialSize ： 默认值是 0, 连接池创建连接的初始连接数目。&nbsp;</p><p class=\"ql-align-justify\">minIdle : 默认是 0, 连接数中最小空闲连接数。&nbsp;</p><p class=\"ql-align-justify\">maxIdle : 默认是 8 ，连接池中最大空闲连接数。&nbsp;</p><p class=\"ql-align-justify\">maxActive : 默认值是 8, 连接池中同时可以分派的最大活跃连接数。&nbsp;</p><p class=\"ql-align-justify\">maxWait : 默认值是无限大，当连接池中连接已经用完了，等待建立一个新连接的最大毫秒数 ( 在抛异常之前 )。&nbsp;</p><p class=\"ql-align-justify\">validationQuery : 一条 sql 语句，用来验证数据库连接是否正常。这条语句必须是一个查询模式，并至少返回一条数据。一般用“ select 1 ”。&nbsp;</p><p class=\"ql-align-justify\">minEvictableIdleTimeMilis : 默认值是 1000 * 60 * 30(30 分钟 ) 单位也是毫秒，连接池中连接可空闲的时间。&nbsp;</p><p class=\"ql-align-justify\">timeBetweenEvictionRunsMilis : 默认值是 -1 ，每隔一段多少毫秒跑一次回收空闲线程的线程。</p><p class=\"ql-align-justify\">对于minEvictableIdleTimeMilis、timeBetweenEvictionRunsMilis这两个参数，timeBetweenEvictionRunsMilis必须大于1且小于minEvictableIdleTimeMilis，建议是minEvictableIdleTimeMilis的五分之一或十分之一。</p><p class=\"ql-align-justify\"><strong>（5）对于前端的几点建议</strong></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">1.7.1、一些图片压缩后再使用，性能方面提高不小吧（可以使用熊猫图片压缩）。虽然自己前端比较菜，但是估计也有不少猿友跟我一样偶尔需要兼顾前端吧。毕竟刚毕业不久。</p><p class=\"ql-align-justify\">1.7.2、关于移动端页面重构兼容不同屏幕大小的问题，建议doc的fontSize，实时获取屏幕的宽度，然后除以320再乘以16，当然16可以根据自己情况去调。然后其他一些单位尽量用rem，这样无论什么大小的屏幕都等比例缩放。感觉比@media效果好很多。</p><p class=\"ql-align-justify\">关于技术积累这一块，之前罗列的提纲还挺多的，写到后面感觉没什么精力了，有些三言两语似乎说不清楚啊。</p><h2><strong style=\"color: rgb(249, 3, 21);\">二、工作心得</strong></h2><p class=\"ql-align-justify\"><strong>（1）沟通协作第一：</strong></p><p class=\"ql-align-justify\">工作中必然少不了团队协作，积极主动去沟通的人做事总是更加靠谱。道理大家都懂。但是我们需要把想法问题，简洁明确的表达给对方。另外总是以沟通的心态面对问题，而不是抱怨。如果觉得上级分配的任务难度太大了，你可以尝试跟他沟通，获取他有很好的建议或解决方案。</p><p class=\"ql-align-justify\"><strong>（2）谨慎记录与排漏：</strong></p><p class=\"ql-align-justify\">感觉现在挺经常是开一两个会，测试同时偶尔找你排查一下环境问题，一天下来其实写代码的时间并不多。一些关键点，非常建议提前记录下来，方便接回被打断的思路，同时避免一些逻辑或功能点的遗漏。</p><p class=\"ql-align-justify\"><strong>（3）思路清晰与效率：</strong></p><p class=\"ql-align-justify\">建议动手写代码之前，建议先理清思路，关键逻辑，需求细节，这样后面写代码的时候效率比较高，而且质量也比较好。</p><p class=\"ql-align-justify\"><strong>（4）主动与多管闲事：</strong></p><p class=\"ql-align-justify\">清楚自己的工作范围，自己心里有个界限，有些属于别人工作范围的事情，可以你提出的建议是好的，但是最好还是在合适的场景和时机提出。</p><p class=\"ql-align-justify\"><strong>（5）心态与工作状态：</strong></p><p class=\"ql-align-justify\">程序员，总会有被坑的时候，或者不顺心的时候，尽量尝试控制一下自己的心态。</p><p class=\"ql-align-justify\"><strong>（6）可持续发展观看待技术与业务：</strong></p><p class=\"ql-align-justify\">这点是我自己希望做到的。对于责任心而言，或者是说一个优秀的程序员。很多时候并不是完成产品提的需求就好了。多为它着想，代码可维护性和扩展性高不高。一些功能点也可以提出自己的想法，不要总是被动的接受产品的需求，业务功能拓展性好的话，可以减少产品改动需求。</p><h2><strong style=\"color: rgb(249, 3, 21);\">三、学习方向与职业发展</strong></h2><p class=\"ql-align-justify\"><strong>（1）先广后深还是先深后广：</strong></p><p class=\"ql-align-justify\">对于博主而言，其实接触的技术点还算比较多的，但是了解的都不深入，个人性格而言，比较偏向于实用驱动，如果在实际使用场景有用到再去深入学习，这样边学边用才能比较集中注意力。像一些同事，他们喜欢把一样东西研究得很深。</p><p class=\"ql-align-justify\"><strong>（2）业务经验也应当注重：</strong></p><p class=\"ql-align-justify\">技术人员必然是技术优先，但是等你到了一定工作年限，其实业务经验也是非常重要了。之前领导找我年度工作谈话就有说过他们招高级工程师的时候对业务经验也非常看重，是否有自己独特的见解。相信道理大家都懂，但是平时有没有这样的意识，有没有去做又是另外一方面了。平时也可以多学习业务方面的知识。</p><p class=\"ql-align-justify\"><strong>（3）相同的工作年限为什么当过项目经理的人更吃香：</strong></p><p class=\"ql-align-justify\">因为他们对业务理解更加深入，代码质量问题落在他头上，项目的人员协调与时间安排规划，责任越大，思考的问题就越多，遇到的问题处理经验就越丰富。把控能力也比较强。</p><p class=\"ql-align-justify\"><strong>（4）怎样能进入学习状态，并且坚持：</strong></p><p class=\"ql-align-justify\">要想集中注意力学习技术，需要安静的环境，需要耐得住寂寞，因此你需要没有人打扰的环境，比如在一个集体居住环境，几个朋友一起住，一般多数回想着去哪玩，朋友在玩游戏，估计也是对你的一种诱惑吧。可以早点到办公室学习或下班学习一段时间再回去。或者选择自己一个人住。</p><p class=\"ql-align-justify\"><strong>（5）如何把握住学习的时机：</strong></p><p class=\"ql-align-justify\">学习最能集中注意力的情况是有着比较强的好奇心和求知欲。所以一般一些技术分享或者老员工讨论的问题，可能很多概念知识你都不懂，这时候你就可以去学习了解这些知识。或者你工作中遇到的问题，尽量刨根问底的去弄清楚是什么原因导致的，不要一些老司机帮忙解决了就一了了之。或者是其他同事遇到的问题，你都可以去了解一下。</p><p class=\"ql-align-justify\"><strong>（6）你更适合走一条怎样的职业道路：</strong></p><p class=\"ql-align-justify\">刚毕业不久的猿友，一般都是会比较心浮气躁的，对技术求知欲很强，特别是一些高大上的技术，什么大数据、云计算、架构等等，有些偏向于技术研究，有些偏向于业务。大部分程序员可能都会选择偏向于技术研究的，于是乎对偏向业务的不怎么感冒，因此觉得天天做这些东西没什么意思。这时候，静下来分析一下，你到底适合哪种方向。你能否静下心来对技术研究很深入，能否耐得住寂寞。</p><h2><strong style=\"color: rgb(249, 3, 21);\">四、关于生活</strong></h2><p class=\"ql-align-justify\"><strong>（1）良好与糟糕的生活状态的区别：</strong></p><p class=\"ql-align-justify\">需要警惕一下自己是否进入了一种糟糕的生活状态，工作上不温不火，似乎现在的技术已经足够用了，完全没有目标没有计划，无法集中注意力学习，日子就这样一天天过去。</p><p class=\"ql-align-justify\"><strong>（2）自己的一些期望：</strong></p><p class=\"ql-align-justify\">希望活得更坚定些，保持着一定的求知欲和规划，向成为自己希望成为的人努力吧，包括一些习惯、处事方式等等。</p><p><br></p>', '1', '3', '待审核', '2');
INSERT INTO `tb_paper` VALUES ('26', 'BLE 4.0 协议知识点总结', '2018-06-15 09:19:41', null, '<p class=\"ql-align-justify\">写在前面：本文参考了&nbsp;<strong>BLE4.0 低功耗蓝牙 协议 总结 ，</strong>对其进行了缩减，整理出了个人能理解的感觉比较基本的内容，有问题请随时跟我沟通 个人QQ：993650814.</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp;&nbsp;</strong></p><p class=\"ql-align-justify\">1、射频信道：</p><p class=\"ql-align-justify\">频率分布图：</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614094332363?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;即最小频率是2402MHz，最大频率是2480MHz.一共有40个信道，信道的宽度是2MHz，其中37个信道为自适应调频数据通道，用来两个链接的设备进行数据通信，3个固定通道37、38、39信道为广播信道用来广播数据。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;三个广播信道分布在SIM频段的不同区域，如果他们集中在某个频段的话，有可能这个频段深度衰落导致广播无法进行，所以广播信道之间至少差24MHz，数据信道在广播信道之间排布，间隔2Mhz。数据信道编号0~36，广播信道编号37~39.</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614111643212?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/2018061411165769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">&nbsp;&nbsp;自适应调频：在传输数据过程中，并不能保证每个信道都是好的信道，自适应调频能够将已知的坏信道映射到已知的好信道上来，防止传输干扰。</p><p class=\"ql-align-justify\">2、发射功率</p><p class=\"ql-align-justify\">2.4GHz频道对无需授权的的设备有发射功率的限制，BLE 4.0限制如下：</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614094943353?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">最低发射功率为-20dBm即10uW，最大发射功率10dBm，10000uW。</p><p class=\"ql-align-justify\">3、bit数据流格式</p><p class=\"ql-align-justify\">&nbsp;&nbsp;协议中PDU都是以Little Endian Format（小端模式）存放的，即内存中的高地址对应高字节，低地址对应低字节，数据传输时最低字节的最低bit最先发送的空中，例如 发送0xD即（0b）1101，则先发送1，接着0，然后1，最后1.</p><p class=\"ql-align-justify\">&nbsp;&nbsp;然而，数据包中的CRC和MIC（&nbsp;Message Integrity Check 信息完整性检查）不是以小端模式存放，并以小端模式发送数据的，而是最先发送的高字节，例如CRC =0x123456，则发送顺序为0x12、0x34、0x56</p><p class=\"ql-align-justify\">4、LL链路层数据包结构分析</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614100955869?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">4.1前导码Preamble：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;前导码为1Byte，要么01010101b，要么10101010b，如果可接入地址Access Address最低位为1时，前导码为01010101b，如果Access Address最低位为0时，前导码为10101010b，目的是为了保证报文的前9bit都是0和1的交替位（理解这句话一定要站在小端模式场景下）。</p><p class=\"ql-align-justify\">4.2接入地址 Accress Address：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;接入地址4Bytes，分为广播接入地址和数据接入地址。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;广播接入地址：固定为&nbsp;0x8e89bed6，发送到空中的格式：</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614102017962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">&nbsp;&nbsp;数据接入地址：数据通道接入地址是一个随机数，由主机产生，但满足如下条件：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;(1)、不是广播通道接入地址；</p><p class=\"ql-align-justify\">&nbsp;&nbsp;(2)、不能超过连续的6个0或者1；</p><p class=\"ql-align-justify\">&nbsp;&nbsp;(3)、4个Bytes必须互不相等；</p><p class=\"ql-align-justify\">&nbsp;&nbsp;(4)、不能超过24bit的翻转，即不能010101010101010101010101；</p><p class=\"ql-align-justify\">&nbsp;&nbsp;(5)、地址的最高 6bits 至少有两次的翻转</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">&nbsp;&nbsp;4.3 广播通道下的PDU</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://img-blog.csdn.net/20180614102851200?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">&nbsp;&nbsp;报文类型（最低4bit）：共有7种广播报文类型，如下：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; ADV_IND——通用广播</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; ADV_DIRECT_IND——定向连接广播</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; ADV_NONCONN_IND——不可连接广播</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; ADV_SCAN_IND——可扫描广播</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; SCAN_REQ——主动扫描请求</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; SCAN_RSP——主动扫描应答</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; CONNECT_REQ——连接请求</p><p class=\"ql-align-justify\">&nbsp;&nbsp;发送地址（TXADDR）和接收地址（RXADDR），用来说明设备的地址类型，为1时表示Random Addr（随机地址），为0时表示Public Addr（公共地址）。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;净荷长度6bit：用来表示净荷数据的长度，LL PDU的最大长度为37Bytes。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;RFU：保留将来用的意思，Reserve for future</p><p class=\"ql-align-justify\">&nbsp;&nbsp;广播通道下PDU的数据净荷（PayLoad）的格式</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://img-blog.csdn.net/20180614104125513?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">&nbsp;&nbsp;4.4 数据通道下的PDU</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://img-blog.csdn.net/20180614104943144?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">注意：这里的数据净荷为什么是216bits也就是27Bytes了，即使加上4Bytes的MIC也只有31Bytes另外6Bytes去哪了？实际上BLE4.0协议规范就是这么规定的，这6Bytes在广播通道下作为蓝牙地址，在数据通道中只有27Bytes。在我的另一篇博客中也有讲到这里 ，可参考如下链接</p><p class=\"ql-align-justify\"><a href=\"https://blog.csdn.net/weixin_40204595/article/details/80597854\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">Nordic Ble 4.0为什么上层应用每次最多能透传20Bytes的有效数据</a></p><p class=\"ql-align-justify\">5、非连接状态：就绪态、广播态、扫描状态、发起状态</p><p class=\"ql-align-justify\">&nbsp;&nbsp;就绪态是默认的状态，直接略过。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.1&nbsp;&nbsp;&nbsp;&nbsp;广播态：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1广播通道选择：在广播态下，LL层通过广播信道发送PDU，广播事件分为 四中：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; 非定向可连接事件(ADV_IND)</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; 定向可连接事件(ADV_DIRECT_IND)</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; 非定向不可连接事件(ADV_NONCONN_IND)</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp; 非定向扫描事件(ADV_DISCOVER_IND/ADV_SCAN_IND)</p><p class=\"ql-align-justify\">&nbsp;&nbsp;广播事件来了之后，PDU依次从37.38.39三个信道传输数据</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/2018061411401635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2&nbsp;广播间隔： 所有的非定向广播事件，两个连续广播事件之间的时间就是广播间隔。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://img-blog.csdn.net/20180614115103676?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIwNDU5NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;advInterval：0.625ms的倍数，在20ms~10.24s之间。advDelay 是个随机数在0~10ms之间，由于设备之间的时钟会有不同程度的漂移，advDelay不但能消除设备之间时间的漂移，还能避免同一信道及时间节点上的冲突。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.1.3 非定向可连接广播事件（ADV_IND）</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链路层通过广播信道发送（ADV_IND PDU）通用广播报文，这个报文发出之后可以接受由扫描者发送的（SCAN_REQ PDU）扫描请求或者由发起者发送的（CONNECT_REQ PDU）连接请求。广播者接受之后，需要在同一信道上进行扫描着或者广播者的应答。&nbsp;如果接受到的SCAN_REQ PDU通过了滤波，那么广播者需要在接受通道上发送SCAN_RSP PDU扫描应答报文。&nbsp;如果 接收到CONN_REQ，那么久进入连接态了。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.1.4 定向可连接广播事件（ADV_DIRECT_IND）</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个广播的目的是为了快速连接，这种报文包含了两个地址：广播者地址和发起者地址。发起者收到发送给自己的广播报文之后，可以快速发起连接请求事件，从而进入连接态。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.1.5 非定向不可连接事件（ADV_NOCONN_IND）</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有自己广播，不允许连接。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.2&nbsp;扫描态</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫描窗口：是链路层监听广播数据通道的持续的时间。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扫描间隔：是连续两个扫描窗口开始的时间之差。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.3 发起态</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发起态进入连接之后成为主机设备。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.4 连接态</p><p class=\"ql-align-justify\">&nbsp;&nbsp;进入连接态后，两个设备就担任了不同的角色。 发送CONNECT REQ的设备成为主机，接受CONNEXT REQ的设备成为从机。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.4.1 连接事件</p><p class=\"ql-align-justify\">&nbsp;&nbsp;跟广播事件一样，每隔一段时间的连接事件都会由主机通过数据信道发送给从机一个数据包，这时候如果从机有数据要回应给主机，就会在150±2us内给主机一个应答。也就是说每个连接事件，都会至少包含主机发送给从机的一个数据包，从机可以不发送给主机。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;连接事件的时间由两个参数决定：connect event interval （connInterval 连接间隔）和slave latency（connSlaveLatency 从机潜伏&nbsp;周期）。解释一下从机潜伏周期：这是一个次数而不是时间，例如connSlaveLatency=5，则连续5个连接事件，从机可以不发数据给主机，主机也不会认为此时断连。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;锚点（anchor point）：连接事件开始的时间叫做锚点，主机在锚点开始连接事件，从机在锚点开始进入侦听状态。</p><p class=\"ql-align-justify\">&nbsp;&nbsp;5.4.2 监管超时</p><p class=\"ql-align-justify\">&nbsp;&nbsp;在连接状态下，长时间的没有连接事件或者长时间主机给从机发送数据，从机没有回应，这时候可以认为连接已经出了问题，这个时间就叫做连接监管超时（connect supervision timeout&nbsp;&nbsp;connSupervisionTimeout）。这个事件一定要大于（connInterval）*（1+connSlaveLatency），并且得是10ms的倍数，并且在100ms~30s之间。</p><p><br></p>', '1', '2', '登记中', '3');
INSERT INTO `tb_paper` VALUES ('27', '网络爬虫的规则', '2018-06-15 09:21:39', null, '<h3>网络爬虫引发的问题</h3><h4>网络爬虫的尺寸</h4><p class=\"ql-align-center\"><img src=\"https://img-blog.csdn.net/20170904214125228?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFmZW5neGlhb3l1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" width=\"500\"></p><h4>网络爬虫的“性能骚扰”</h4><p class=\"ql-align-justify\">Web服务器默认接收人类访问</p><p class=\"ql-align-justify\">受限于编写水平和目的，网络爬虫将会为Web服务器带来巨大的资源开销</p><h4>网络爬虫的法律风险</h4><p class=\"ql-align-justify\">服务器上的数据有产权归属</p><p class=\"ql-align-justify\">网络爬虫获取数据后牟利将带来法律风险</p><h4>网络爬虫的隐私泄露</h4><p class=\"ql-align-justify\">网络爬虫可能具备突破简单访问控制的能力，获得被保护数据</p><p class=\"ql-align-justify\">从而泄露个人隐私</p><h4>网络爬虫引发的问题</h4><p class=\"ql-align-justify\">性能骚扰</p><p class=\"ql-align-justify\">法律风险</p><p class=\"ql-align-justify\">隐私泄露</p><h4>网络爬虫的限制</h4><p class=\"ql-align-justify\">• 来源审查：判断User‐Agent进行限制</p><p class=\"ql-align-justify\">&nbsp;&nbsp;检查来访HTTP协议头的User‐Agent域，只响应浏览器或友好爬虫的访问</p><p class=\"ql-align-justify\">• 发布公告：Robots协议</p><p class=\"ql-align-justify\">&nbsp;&nbsp;告知所有爬虫网站的爬取策略，要求爬虫遵守</p><p class=\"ql-align-justify\"><br></p><h3>Robots协议</h3><h4>Robots协议</h4><p class=\"ql-align-center\"><span style=\"color: rgb(255, 0, 0);\">Robots Exclusion Standard</span>，网络爬虫排除标准</p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">作用：</span></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">&nbsp;&nbsp;网站告知网络爬虫哪些页面可以抓取，哪些不行</span></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">形式：</span></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">&nbsp;&nbsp;在网站根目录下的robots.txt文件</span></p><p class=\"ql-align-justify\"><br></p><h4>案例：京东的 Robots协议</h4><p class=\"ql-align-justify\">https://www.jd.com/robots.txt</p><p><strong>[plain]</strong>&nbsp;<a href=\"https://blog.csdn.net/lafengxiaoyu/article/details/77842362#\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/lafengxiaoyu/article/details/77842362#\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">copy</a></p><ol><li><span style=\"color: black; background-color: inherit;\">User‐agent:&nbsp;*&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">Disallow:&nbsp;/?*&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">Disallow:&nbsp;/pop/*.html&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">Disallow:&nbsp;/pinpai/*.html?*&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">User‐agent:&nbsp;EtaoSpider&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">Disallow:&nbsp;/&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">User‐agent:&nbsp;HuihuiSpider&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">Disallow:&nbsp;/&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">User‐agent:&nbsp;GwdangSpider&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">Disallow:&nbsp;/&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">User‐agent:&nbsp;WochachaSpider&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">Disallow:&nbsp;/&nbsp;&nbsp;</span></li></ol><p><strong>[plain]</strong>&nbsp;<a href=\"https://blog.csdn.net/lafengxiaoyu/article/details/77842362#\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/lafengxiaoyu/article/details/77842362#\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">copy</a></p><ol><li><span style=\"color: black; background-color: inherit;\">#&nbsp;注释，*代表所有，/代表根目录&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">User‐agent:&nbsp;*&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">Disallow:&nbsp;/&nbsp;&nbsp;</span></li></ol><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">Robots协议基本语法</span></p><h4>案例：真实的Robots协议</h4><p class=\"ql-align-justify\">http://www.baidu.com/robots.txt</p><p class=\"ql-align-justify\">http://news.sina.com.cn/robots.txt</p><p class=\"ql-align-justify\">http://www.qq.com/robots.txt</p><p class=\"ql-align-justify\">http://news.qq.com/robots.txt</p><p class=\"ql-align-justify\">http://www.moe.edu.cn/robots.txt （无robots协议）</p><p class=\"ql-align-justify\"><br></p><h3>Robots协议的遵守方式</h3><p class=\"ql-align-justify\">实际操作中，该如何遵守Robots协议？</p><h4>Robots协议的使用</h4><p class=\"ql-align-justify\">网络爬虫：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;自动或人工识别robots.txt，再进行内容爬取</p><p class=\"ql-align-justify\">约束性：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;Robots协议是建议但非约束性，网络爬虫可以不遵守，但存在法律风险</p><p class=\"ql-align-justify\"><br></p><h4>对Robots协议的理解</h4><p class=\"ql-align-center\"><img src=\"https://img-blog.csdn.net/20170904215755215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGFmZW5neGlhb3l1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" width=\"500\"></p><p><br></p>', '1', '1', '登记中', '4');
INSERT INTO `tb_paper` VALUES ('28', 'Windows命令行安装mysql', '2018-06-15 09:23:36', null, '<p class=\"ql-align-justify\">1、解压win的包到某个目录下</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614133131581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NjAxMTg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">2、在DOS命令切换到该路径</p><p class=\"ql-align-justify\">语法：cd /d 目标路径</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614133522148?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NjAxMTg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">3、DOS命令生成数据文件date</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614133849247?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NjAxMTg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614134010225?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NjAxMTg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">4、安装并且启动mysql</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614134046176?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NjAxMTg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">5、如果在安装过程中出现Install/Remove of the Service Denied错误，</p><p class=\"ql-align-justify\">请在打开cmd.exe程序的时候选择“用管理员身份打开”即可。</p><p><br></p>', '1', '2', '登记中', '1');
INSERT INTO `tb_paper` VALUES ('29', 'MYSQL性能优化的最佳20+条经验', '2018-06-15 09:24:29', null, '<p class=\"ql-align-justify\">今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们不会讲过多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">1、为查询缓存优化你的查询</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：</p><p class=\"ql-align-justify\"><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 查询缓存不开启\n$r = mysql_query(\"SELECT username FROM user WHERE signup_date &gt;= CURDATE()\");\n// 开启查询缓存\n$today = date(\"Y-m-d\");\n$r = mysql_query(\"SELECT username FROM user WHERE signup_date &gt;= \'$today\'\");\n</pre><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">2、EXPLAIN 你的 SELECT 查询</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">使用&nbsp;EXPLAIN&nbsp;关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">挑一个你的SELECT语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接：</p><p class=\"ql-align-justify\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://img-blog.csdn.net/20180614133218482\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-center\">当我们为 group_id 字段加上索引后：</p><p class=\"ql-align-center\"><img src=\"https://img-blog.csdn.net/20180614133243149\"></p><p class=\"ql-align-justify\">我们可以看到，前一个结果显示搜索了 7883 行，而后一个只是搜索了两个表的 9 和 16 行。查看rows列可以让我们找到潜在的性能问题。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">3、当只要一行数据时使用 LIMIT 1</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select *，第二条是Select 1）</p><p class=\"ql-align-justify\"><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 没有效率的：\n$r = mysql_query(\"SELECT * FROM user WHERE country = \'China\'\");\nif (mysql_num_rows($r) &gt; 0) {\n &nbsp; &nbsp;// ...\n}\n// 有效率的：\n$r = mysql_query(\"SELECT 1 FROM user WHERE country = \'China\' LIMIT 1\");\nif (mysql_num_rows($r) &gt; 0) {\n &nbsp; &nbsp;// ...\n}\n</pre><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">4、为搜索字段建索引</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-center\"><img src=\"https://img-blog.csdn.net/20180614133333735\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">从上图你可以看到那个搜索字串 “last_name LIKE ‘a%\'”，一个是建了索引，一个是没有索引，性能差了4倍左右。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">另外，你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如： “WHERE post_content LIKE ‘%apple%\'”，索引可能是没有意义的。你可能需要使用MySQL全文索引&nbsp;或是自己做一个索引（比如说：搜索关键词或是Tag什么的）</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">5、在Join表的时候使用相当类型的例，并将其索引</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）</p><p class=\"ql-align-justify\"><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 在state中查找company\n$r = mysql_query(\"SELECT company_name FROM users\n &nbsp; &nbsp;LEFT JOIN companies ON (users.state = companies.state)\n &nbsp; &nbsp;WHERE users.id = $user_id\");\n// 两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。\n</pre><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">6、千万不要 ORDER BY RAND()</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">下面的示例是随机挑一条记录</p><p class=\"ql-align-justify\"><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 千万不要这样做：\n$r = mysql_query(\"SELECT username FROM user ORDER BY RAND() LIMIT 1\");\n// 这要会更好：\n$r = mysql_query(\"SELECT count(*) FROM user\");\n$d = mysql_fetch_row($r);\n$rand = mt_rand(0,$d[0] - 1);\n$r = mysql_query(\"SELECT username FROM user LIMIT $rand, 1\");\n</pre><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">7、避免 SELECT *</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">所以，你应该养成一个需要什么就取什么的好的习惯。</p><p class=\"ql-align-justify\"><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 不推荐\n$r = mysql_query(\"SELECT * FROM user WHERE user_id = 1\");\n$d = mysql_fetch_assoc($r);\necho \"Welcome {$d[\'username\']}\";\n// 推荐\n$r = mysql_query(\"SELECT username FROM user WHERE user_id = 1\");\n$d = mysql_fetch_assoc($r);\necho \"Welcome {$d[\'username\']}\";\n</pre><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">8/永远为每张表设置一个ID</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">9、使用 ENUM 而不是 VARCHAR</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">ENUM&nbsp;类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">10、从 PROCEDURE ANALYSE() 取得建议</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">PROCEDURE ANALYSE()&nbsp;会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">在phpmyadmin里，你可以在查看表时，点击 “Propose table structure” 来查看这些建议</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-center\"><img src=\"https://img-blog.csdn.net/2018061413340819\"></p><p class=\"ql-align-justify\">一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">11、尽可能的使用 NOT NULL</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">下面摘自MySQL自己的文档：</p><p class=\"ql-align-justify\"><br></p><blockquote class=\"ql-align-justify\">“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”</blockquote><h4><br></h4><h4><span style=\"color: rgb(171, 25, 66);\">12、Prepared Statements</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候，这样的问题会好一些。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本5.1后支持了。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">在PHP中要使用prepared statements，你可以查看其使用手册：mysqli 扩展&nbsp;或是使用数据库抽象层，如：&nbsp;PDO.</p><p class=\"ql-align-justify\"><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// 创建 prepared statement\nif ($stmt = $mysqli-&gt;prepare(\"SELECT username FROM user WHERE state=?\")) {\n &nbsp; &nbsp;// 绑定参数\n &nbsp; &nbsp;$stmt-&gt;bind_param(\"s\", $state);\n &nbsp; &nbsp;// 执行\n &nbsp; &nbsp;$stmt-&gt;execute();\n &nbsp; &nbsp;// 绑定结果\n &nbsp; &nbsp;$stmt-&gt;bind_result($username);\n &nbsp; &nbsp;// 移动游标\n &nbsp; &nbsp;$stmt-&gt;fetch();\n &nbsp; &nbsp;printf(\"%s is from %s\n\", $username, $state);\n &nbsp; &nbsp;$stmt-&gt;close();\n}\n</pre><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">13、无缓冲的查询</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">正常的情况下，当你在当你在你的脚本中执行一个SQL语句的时候，你的程序会停在那里直到没这个SQL语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">关于这个事情，在PHP的文档中有一个非常不错的说</p><p class=\"ql-align-justify\">明：&nbsp;mysql_unbuffered_query()&nbsp;函数：</p><p class=\"ql-align-justify\"><br></p><blockquote class=\"ql-align-justify\">“mysql_unbuffered_query() sends the SQL query query to MySQL without automatically fetching and buffering the result rows as mysql_query() does. This saves a considerable amount of memory with SQL queries that produce large result sets, and you can start working on the result set immediately after the first row has been retrieved as you don’t have to wait until the complete SQL query has been performed.”</blockquote><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">上面那句话翻译过来是说，mysql_unbuffered_query() 发送一个SQL语句到MySQL而并不像mysql_query()一样去自动fethch和缓存结果。这会相当节约很多可观的内存，尤其是那些会产生大量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。</p><p class=\"ql-align-justify\">然而，这会有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用&nbsp;mysql_free_result()&nbsp;清除结果。而且，&nbsp;mysql_num_rows()&nbsp;或&nbsp;mysql_data_seek()&nbsp;将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">14、把IP地址存成 UNSIGNED INT</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形。</p><p class=\"ql-align-justify\">而你的查询，你可以使用&nbsp;INET_ATON()&nbsp;来把一个字符串IP转成一个整形，并使用&nbsp;INET_NTOA()&nbsp;把一个整形转成一个字符串IP。在PHP中，也有这样的函数&nbsp;ip2long()&nbsp;和&nbsp;long2ip()。</p><p class=\"ql-align-justify\"><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">$r = \"UPDATE users SET ip = INET_ATON(\'{$_SERVER[\'REMOTE_ADDR\']}\') WHERE user_id = $user_id\";\n</pre><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">15、固定长度的表会更快</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">如果表中的所有字段都是“固定长度”的，整个表会被认为是&nbsp;“static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。</p><p class=\"ql-align-justify\">使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">16、垂直分割</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">示例二：&nbsp;你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">17、拆分大的 DELETE 或 INSERT 语句</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：</p><p class=\"ql-align-justify\"><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">while (1) {\n &nbsp; &nbsp;//每次只做1000条\n &nbsp; &nbsp;mysql_query(\"DELETE FROM logs WHERE log_date &lt;= \'2009-11-01\' LIMIT 1000\");\n &nbsp; &nbsp;if (mysql_affected_rows() == 0) {\n &nbsp; &nbsp; &nbsp; &nbsp;// 没得可删了，退出！\n &nbsp; &nbsp; &nbsp; &nbsp;break;\n &nbsp; &nbsp;}\n &nbsp; &nbsp;// 每次都要休息一会儿\n &nbsp; &nbsp;usleep(50000);\n}\n</pre><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">18、越小的列会越快</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">参看 MySQL 的文档&nbsp;Storage Requirements&nbsp;查看所有的数据类型。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">19、选择正确的存储引擎</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3NDA4OTk1OQ==&amp;mid=2649901679&amp;idx=1&amp;sn=d6dc080ab4e2d7d44a1ebf0bcfc0bd48&amp;chksm=f31fb8e7c46831f1e548a09e3a302f10f393ac2082fdffefc5fba57ebdc52b87186b20cfd2ca&amp;scene=21#wechat_redirect\" target=\"_blank\" style=\"color: rgb(67, 149, 245);\">MySQL: InnoDB 还是 MyISAM?</a>》讨论和这个事情。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">下面是MySQL的手册</p><p class=\"ql-align-justify\"><br></p><ul><li class=\"ql-align-justify\">target=”_blank”MyISAM Storage Engine</li><li class=\"ql-align-justify\">InnoDB Storage Engine</li></ul><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">20、使用一个对象关系映射器（Object Relational Mapper）</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">ORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">ORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。</p><p class=\"ql-align-justify\">目前，个人最喜欢的PHP的ORM是：Doctrine。</p><p class=\"ql-align-justify\"><br></p><h4><span style=\"color: rgb(171, 25, 66);\">21、小心“永久链接”</span></h4><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。</p><p class=\"ql-align-justify\"><br></p><ul><li class=\"ql-align-justify\">PHP手册：mysql_pconnect()</li></ul><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。</p><p><br></p>', '1', '2', '登记中', '1');
INSERT INTO `tb_paper` VALUES ('30', 'Redis使用笔记', '2018-06-15 09:31:13', null, '<p class=\"ql-align-justify\">Windows 安装Redis 下载地址 ：&nbsp;<a href=\"https://github.com/MSOpenTech/redis/releases\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">https://github.com/MSOpenTech/redis/releases</a></p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614133439603?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JvZl9qYW5nbGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">redis-server 为启动服务器。</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614133602321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JvZl9qYW5nbGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\">redis-cli 为客户端，使用set,get进行存储与读取，使用shutdown命令关闭所连接的服务器。</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614133734338?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JvZl9qYW5nbGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">接下来是Java链接redis的介绍。 首先我们需要jedis的相关jar包。这个包实现了redis客户端的功能。来进行对远程Redis的存储等相关操作。</p><p class=\"ql-align-justify\">1、jedis2.7.3 jar包 ：http://www.mvnrepository.com/artifact/redis.clients/jedis/2.7.3</p><p class=\"ql-align-justify\">2、连接池所需的 commons-pool2.3 jar包： http://www.mvnrepository.com/artifact/org.apache.commons/commons-pool2/2.3</p><p class=\"ql-align-justify\">3、对象存储所需的fastjson jar包（我们要把对象转换为json字符串格式存储）：https://mvnrepository.com/artifact/com.alibaba/fastjson/1.2.46</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">项目结构如下：</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614134332137?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JvZl9qYW5nbGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" height=\"204\" width=\"340\"></p><p class=\"ql-align-justify\">代码：</p><p class=\"ql-align-justify\">MainTest.java :</p><p><strong>[java]</strong>&nbsp;<a href=\"https://blog.csdn.net/Bof_jangle/article/details/80691610#\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/Bof_jangle/article/details/80691610#\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">copy</a></p><ol><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">package</strong><span style=\"background-color: inherit; color: black;\">&nbsp;xyz.jangle.redis;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">import</strong><span style=\"background-color: inherit; color: black;\">&nbsp;com.alibaba.fastjson.JSON;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">import</strong><span style=\"background-color: inherit; color: black;\">&nbsp;redis.clients.jedis.Jedis;&nbsp;&nbsp;</span></li><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">import</strong><span style=\"background-color: inherit; color: black;\">&nbsp;redis.clients.jedis.JedisPool;&nbsp;&nbsp;</span></li><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">import</strong><span style=\"background-color: inherit; color: black;\">&nbsp;redis.clients.jedis.JedisPoolConfig;&nbsp;&nbsp;</span></li><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">import</strong><span style=\"background-color: inherit; color: black;\">&nbsp;xyz.jangle.redis.vo.UserVo;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">public</strong><span style=\"background-color: inherit; color: black;\">&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">class</strong><span style=\"background-color: inherit; color: black;\">&nbsp;MainTest&nbsp;{&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">public</strong><span style=\"background-color: inherit; color: black;\">&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">static</strong><span style=\"background-color: inherit; color: black;\">&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">void</strong><span style=\"background-color: inherit; color: black;\">&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JedisPoolConfig&nbsp;poolcfg&nbsp;=&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">new</strong><span style=\"background-color: inherit; color: black;\">&nbsp;JedisPoolConfig();&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=\"background-color: inherit; color: rgb(0, 130, 0);\">//最大空闲连接数,&nbsp;默认8个</span><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poolcfg.setMaxIdle(</span><span style=\"background-color: inherit; color: rgb(192, 0, 0);\">200</span><span style=\"background-color: inherit; color: black;\">);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=\"background-color: inherit; color: rgb(0, 130, 0);\">//最大连接数,&nbsp;默认8个</span><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poolcfg.setMaxTotal(</span><span style=\"background-color: inherit; color: rgb(192, 0, 0);\">1000</span><span style=\"background-color: inherit; color: black;\">);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=\"background-color: inherit; color: rgb(0, 130, 0);\">//最小空闲连接数,&nbsp;默认0</span><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poolcfg.setMinIdle(</span><span style=\"background-color: inherit; color: rgb(192, 0, 0);\">50</span><span style=\"background-color: inherit; color: black;\">);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JedisPool&nbsp;pool&nbsp;=&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">new</strong><span style=\"background-color: inherit; color: black;\">&nbsp;JedisPool(poolcfg,&nbsp;</span><span style=\"background-color: inherit; color: blue;\">\"localhost\"</span><span style=\"background-color: inherit; color: black;\">,</span><span style=\"background-color: inherit; color: rgb(192, 0, 0);\">6379</span><span style=\"background-color: inherit; color: black;\">);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jedis&nbsp;jedis&nbsp;=&nbsp;pool.getResource();&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserVo&nbsp;u&nbsp;=&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">new</strong><span style=\"background-color: inherit; color: black;\">&nbsp;UserVo();&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.setId(</span><span style=\"background-color: inherit; color: rgb(192, 0, 0);\">1</span><span style=\"background-color: inherit; color: black;\">);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u.setName(</span><span style=\"background-color: inherit; color: blue;\">\"aName\"</span><span style=\"background-color: inherit; color: black;\">);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;aObj&nbsp;=&nbsp;JSON.toJSONString(u);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedis.set(</span><span style=\"background-color: inherit; color: blue;\">\"aObj\"</span><span style=\"background-color: inherit; color: black;\">,&nbsp;aObj);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;aObjValue&nbsp;=&nbsp;jedis.get(</span><span style=\"background-color: inherit; color: blue;\">\"aObj\"</span><span style=\"background-color: inherit; color: black;\">);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(jedis.get(</span><span style=\"background-color: inherit; color: blue;\">\"aObj\"</span><span style=\"background-color: inherit; color: black;\">));&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserVo&nbsp;uReturn&nbsp;=&nbsp;JSON.parseObject(aObjValue,&nbsp;UserVo.</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">class</strong><span style=\"background-color: inherit; color: black;\">);&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(uReturn.getId());&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(uReturn.getName());&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=\"background-color: inherit; color: rgb(0, 130, 0);\">//删除aObj</span><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=\"background-color: inherit; color: rgb(0, 130, 0);\">//jedis.del(\"aObj\");</span><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jedis.close();&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pool.close();&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">}&nbsp;&nbsp;</span></li></ol><p class=\"ql-align-justify\">UserVo.java :</p><p><strong>[java]</strong>&nbsp;<a href=\"https://blog.csdn.net/Bof_jangle/article/details/80691610#\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/Bof_jangle/article/details/80691610#\" target=\"_blank\" style=\"color: rgb(103, 149, 181);\">copy</a></p><ol><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">package</strong><span style=\"background-color: inherit; color: black;\">&nbsp;xyz.jangle.redis.vo;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">public</strong><span style=\"background-color: inherit; color: black;\">&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">class</strong><span style=\"background-color: inherit; color: black;\">&nbsp;UserVo&nbsp;{&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">private</strong><span style=\"background-color: inherit; color: black;\">&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">int</strong><span style=\"background-color: inherit; color: black;\">&nbsp;id;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">private</strong><span style=\"background-color: inherit; color: black;\">&nbsp;String&nbsp;name;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">public</strong><span style=\"background-color: inherit; color: black;\">&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">int</strong><span style=\"background-color: inherit; color: black;\">&nbsp;getId()&nbsp;{&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">return</strong><span style=\"background-color: inherit; color: black;\">&nbsp;id;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">public</strong><span style=\"background-color: inherit; color: black;\">&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">void</strong><span style=\"background-color: inherit; color: black;\">&nbsp;setId(</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">int</strong><span style=\"background-color: inherit; color: black;\">&nbsp;id)&nbsp;{&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">this</strong><span style=\"background-color: inherit; color: black;\">.id&nbsp;=&nbsp;id;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">public</strong><span style=\"background-color: inherit; color: black;\">&nbsp;String&nbsp;getName()&nbsp;{&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">return</strong><span style=\"background-color: inherit; color: black;\">&nbsp;name;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">public</strong><span style=\"background-color: inherit; color: black;\">&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">void</strong><span style=\"background-color: inherit; color: black;\">&nbsp;setName(String&nbsp;name)&nbsp;{&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><strong style=\"background-color: inherit; color: rgb(0, 102, 153);\">this</strong><span style=\"background-color: inherit; color: black;\">.name&nbsp;=&nbsp;name;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"background-color: inherit; color: black;\">}&nbsp;&nbsp;</span></li></ol><p class=\"ql-align-justify\">控制台输出结果：</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614135003157?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JvZl9qYW5nbGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">windows客户端查看结果：</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614135037786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JvZl9qYW5nbGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"></p><p class=\"ql-align-justify\"><br></p><p><br></p>', '1', '3', '待审核', '1');
INSERT INTO `tb_paper` VALUES ('31', ' Oracle 批量插入数据 insert all into 用法', '2018-06-15 09:32:39', null, '<p class=\"ql-align-justify\">项目需要用到导入excel表，并解析数据批量插入到oracle数据库中。</p><p class=\"ql-align-justify\">1）直接解析excel，循环行，拼了sql，executeUpdate。&nbsp;</p><p class=\"ql-align-justify\">执行一波…&nbsp;</p><p class=\"ql-align-justify\">咦，这效率很低啊，有多少行数据就执行了多少句sql，基本是一万行已经接近一分钟了。&nbsp;</p><p class=\"ql-align-justify\">2）每次都仅执行一条sql语句，时间是不是都花在建立连接放开连接balabala的过程上了，用executebatch批量执行sql语句试试。&nbsp;</p><p class=\"ql-align-justify\">没有任何明显的改善。&nbsp;</p><p class=\"ql-align-justify\">3）那改成一条insert语句效果怎么样呢？&nbsp;</p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614133203232?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1a2FpaXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p><p class=\"ql-align-justify\"><img src=\"https://img-blog.csdn.net/20180614133216656?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1a2FpaXQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p><p class=\"ql-align-justify\">这回效果看起来很明显了，问题看起来要解决了，确实，按这样改到程序里，执行上传excel，解析插入一万行数据到数据库，总共也就差不多一秒钟，能接受了。&nbsp;</p><p class=\"ql-align-justify\">4）但是我还想兼容Oracle，刚才是拿MySql做的实验，Oracle竟然不能这么写：</p><pre class=\"ql-syntax\" spellcheck=\"false\">insert into testimport(username,password,address,telphone,email)\nvalues\n(\'testname\',\'jfksdfkdsfjksadljfkdsfjsdlafjdaslkfjasfd\',\'山东省济南市历城区港兴一路\',\'19876767856\',\'fdsfdsfads@163.com\'),\n(\'testname\',\'jfksdfkdsfjksadljfkdsfjsdlafjdaslkfjasfd\',\'山东省济南市历城区港兴一路\',\'19876767856\',\'fdsfdsfads@164.com\'),\n(\'testname\',\'jfksdfkdsfjksadljfkdsfjsdlafjdaslkfjasfd\',\'山东省济南市历城区港兴一路\',\'19876767856\',\'fdsfdsfads@165.com\')\n1\n2\n3\n4\n5\n</pre><p class=\"ql-align-justify\">那我们在Oracle中，怎么通过一个insert语句批量插入数据呢？</p><pre class=\"ql-syntax\" spellcheck=\"false\">INSERT ALL \nINTO A(field_1,field_2) VALUES (value_1,value_2) \nINTO A(field_1,field_2) VALUES (value_3,value_4) \nINTO A(field_1,field_2) VALUES (value_5,value_6)\nSELECT 1 FROM DUAL;\n</pre><p><br></p>', '1', '1', '登记中', '1');
INSERT INTO `tb_paper` VALUES ('32', ' 用 pycharm 可视化管理 sqlite 数据库', '2018-06-15 09:34:21', null, '<p>目前 pycharm&nbsp;已经集成了数据库可视化管理工具，这样我们就不用额外安装一个数据库管理软件了，也不用在开发的时候同时打开 pycharm 和另一个程序了。</p><p>而且 pycharm 不仅支持 sqlite，它支持几乎所有的主流数据库，很好很强大。</p><p>我用的版本是 pycharm 4.0.4</p><p>废话少说，上图：</p><p><img src=\"http://img0.ph.126.net/yPXHXBCA2SQG1n4Ko6fASg==/6630409158233433333.png\" alt=\"用 pycharm 可视化管理 sqlite 数据库 - oldman - oldman的博客\"></p><p><br></p><p><img src=\"http://img0.ph.126.net/bndjfc901E4i_NZ0hAiWyQ==/2188749419002610403.png\" alt=\"用 pycharm 可视化管理 sqlite 数据库 - oldman - oldman的博客\"></p><p><br></p><p><img src=\"http://img0.ph.126.net/qDxOpdJW0zdsiI4OdXrR3Q==/6619520694584483070.png\" alt=\"用 pycharm 可视化管理 sqlite 数据库 - oldman - oldman的博客\"></p><p><br></p><p><img src=\"http://img2.ph.126.net/doqTjwsF_XObTwMyiucsaA==/3362500071886907420.png\" alt=\"用 pycharm 可视化管理 sqlite 数据库 - oldman - oldman的博客\"></p><p><br></p><p><img src=\"http://img2.ph.126.net/mPJn5H-4Ii9hMe0AJ1xh3w==/6608620136306730707.png\" alt=\"用 pycharm 可视化管理 sqlite 数据库 - oldman - oldman的博客\"></p>', '1', '2', '待审核', '1');
INSERT INTO `tb_paper` VALUES ('33', 'MySQL大表优化方案', '2018-06-15 09:35:14', null, '<blockquote class=\"ql-align-justify\">当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化</blockquote><p><br></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">单表优化</span></p><p class=\"ql-align-justify\">除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">千万级</code>以下，字符串为主的表在<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">五百万</code>以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量：</p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">字段</span></p><ul><li class=\"ql-align-justify\">尽量使用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">TINYINT</code>、<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">SMALLINT</code>、<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">MEDIUM_INT</code>作为整数类型而非<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">INT</code>，如果非负则加上<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">UNSIGNED</code></li><li><br></li><li class=\"ql-align-justify\"><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">VARCHAR</code>的长度只分配真正需要的空间</li><li><br></li><li class=\"ql-align-justify\">使用枚举或整数代替字符串类型</li><li><br></li><li class=\"ql-align-justify\">尽量使用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">TIMESTAMP</code>而非<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">DATETIME</code>，</li><li><br></li><li class=\"ql-align-justify\">单表不要有太多字段，建议在20以内</li><li><br></li><li class=\"ql-align-justify\">避免使用NULL字段，很难查询优化且占用额外索引空间</li><li><br></li><li class=\"ql-align-justify\">用整型来存IP</li><li class=\"ql-align-justify\"><br></li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">索引</span></p><ul><li class=\"ql-align-justify\">索引并不是越多越好，要根据查询有针对性的创建，考虑在<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">WHERE</code>和<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">ORDER BY</code>命令上涉及的列建立索引，可根据<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">EXPLAIN</code>来查看是否用了索引还是全表扫描</li><li><br></li><li class=\"ql-align-justify\">应尽量避免在<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">WHERE</code>子句中对字段进行<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">NULL</code>值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li><br></li><li class=\"ql-align-justify\">值分布很稀少的字段不适合建索引，例如\"性别\"这种只有两三个值的字段</li><li><br></li><li class=\"ql-align-justify\">字符字段只建前缀索引</li><li><br></li><li class=\"ql-align-justify\">字符字段最好不要做主键</li><li><br></li><li class=\"ql-align-justify\">不用外键，由程序保证约束</li><li><br></li><li class=\"ql-align-justify\">尽量不用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">UNIQUE</code>，由程序保证约束</li><li><br></li><li class=\"ql-align-justify\">使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li><li class=\"ql-align-justify\"><br></li></ul><h4>查询SQL</h4><p><br></p><ul><li class=\"ql-align-justify\">可通过开启慢查询日志来找出较慢的SQL</li><li><br></li><li class=\"ql-align-justify\">不做列运算：<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">SELECT id WHERE age + 1 = 10</code>，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li><li><br></li><li class=\"ql-align-justify\">sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库</li><li><br></li><li class=\"ql-align-justify\">不用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">SELECT *</code></li><li><br></li><li class=\"ql-align-justify\"><code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">OR</code>改写成<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">IN</code>：<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">OR</code>的效率是n级别，<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">IN</code>的效率是log(n)级别，in的个数建议控制在200以内</li><li><br></li><li class=\"ql-align-justify\">不用函数和触发器，在应用程序实现</li><li><br></li><li class=\"ql-align-justify\">避免<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">%xxx</code>式查询</li><li><br></li><li class=\"ql-align-justify\">少用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">JOIN</code></li><li><br></li><li class=\"ql-align-justify\">使用同类型进行比较，比如用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">\'123\'</code>和<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">\'123\'</code>比，<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">123</code>和<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">123</code>比</li><li><br></li><li class=\"ql-align-justify\">尽量避免在<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">WHERE</code>子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li><li><br></li><li class=\"ql-align-justify\">对于连续数值，使用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">BETWEEN</code>不用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">IN</code>：<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">SELECT id FROM t WHERE num BETWEEN 1 AND 5</code></li><li><br></li><li class=\"ql-align-justify\">列表数据不要拿全表，要使用<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">LIMIT</code>来分页，每页数量也不要太大</li><li class=\"ql-align-justify\"><br></li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">引擎</span></p><p class=\"ql-align-justify\">目前广泛使用的是MyISAM和InnoDB两种引擎：</p><h5>MyISAM</h5><p><br></p><p class=\"ql-align-justify\">MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</p><ul><li class=\"ql-align-justify\">不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li><li><br></li><li class=\"ql-align-justify\">不支持事务</li><li><br></li><li class=\"ql-align-justify\">不支持外键</li><li><br></li><li class=\"ql-align-justify\">不支持崩溃后的安全恢复</li><li><br></li><li class=\"ql-align-justify\">在表有读取查询的同时，支持往表中插入新纪录</li><li><br></li><li class=\"ql-align-justify\">支持<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">BLOB</code>和<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">TEXT</code>的前500个字符索引，支持全文索引</li><li><br></li><li class=\"ql-align-justify\">支持延迟更新索引，极大提升写入性能</li><li><br></li><li class=\"ql-align-justify\">对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li><li class=\"ql-align-justify\"><br></li></ul><h5>InnoDB</h5><p><br></p><p class=\"ql-align-justify\">InnoDB在MySQL 5.5后成为默认索引，它的特点是：</p><ul><li class=\"ql-align-justify\">支持行锁，采用MVCC来支持高并发</li><li><br></li><li class=\"ql-align-justify\">支持事务</li><li><br></li><li class=\"ql-align-justify\">支持外键</li><li><br></li><li class=\"ql-align-justify\">支持崩溃后的安全恢复</li><li><br></li><li class=\"ql-align-justify\">不支持全文索引</li><li class=\"ql-align-justify\"><br></li></ul><p class=\"ql-align-justify\">总体来讲，MyISAM适合<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">SELECT</code>密集型的表，而InnoDB适合<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">INSERT</code>和<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">UPDATE</code>密集型的表</p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">系统调优参数</span></p><p class=\"ql-align-justify\">可以使用下面几个工具来做基准测试：</p><ul><li class=\"ql-align-justify\">sysbench：一个模块化，跨平台以及多线程的性能测试工具</li><li><br></li><li class=\"ql-align-justify\">iibench-mysql：基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具</li><li><br></li><li class=\"ql-align-justify\">tpcc-mysql：Percona开发的TPC-C测试工具</li><li class=\"ql-align-justify\"><br></li></ul><p class=\"ql-align-justify\">具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：</p><ul><li class=\"ql-align-justify\">back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500</li><li><br></li><li class=\"ql-align-justify\">wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时</li><li><br></li><li class=\"ql-align-justify\">max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限</li><li><br></li><li class=\"ql-align-justify\">thread_concurrency：并发线程数，设为CPU核数的两倍</li><li><br></li><li class=\"ql-align-justify\">skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问</li><li><br></li><li class=\"ql-align-justify\">key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">show status like \'key_read%\'</code>，保证<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">key_reads / key_read_requests</code>在0.1%以下最好</li><li><br></li><li class=\"ql-align-justify\">innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">show status like \'Innodb_buffer_pool_read%\'</code>，保证<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">(Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests</code>越高越好</li><li><br></li><li class=\"ql-align-justify\">innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小</li><li><br></li><li class=\"ql-align-justify\">innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB</li><li><br></li><li class=\"ql-align-justify\">query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))</code>进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大.</li><li class=\"ql-align-justify\">可以通过命令<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">show status like \'Qcache_%\'</code>查看目前系统Query catch使用大小</li><li class=\"ql-align-justify\">read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能</li><li><br></li><li class=\"ql-align-justify\">sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">ORDER BY</code>的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小</li><li><br></li><li class=\"ql-align-justify\">read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</li><li><br></li><li class=\"ql-align-justify\">record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值</li><li><br></li><li class=\"ql-align-justify\">thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的</li><li><br></li><li class=\"ql-align-justify\">table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM</li><li class=\"ql-align-justify\"><br></li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">升级硬件</span></p><p class=\"ql-align-justify\">Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能</p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">读写分离</span></p><p class=\"ql-align-justify\">也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离</p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">缓存</span></p><p class=\"ql-align-justify\">缓存可以发生在这些层次：</p><ul><li class=\"ql-align-justify\">MySQL内部：在系统调优参数介绍了相关设置</li><li><br></li><li class=\"ql-align-justify\">数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">Persistence Object</code></li><li><br></li><li class=\"ql-align-justify\">应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">Data Transfer Object</code></li><li><br></li><li class=\"ql-align-justify\">Web层：针对web页面做缓存</li><li><br></li><li class=\"ql-align-justify\">浏览器客户端：用户端的缓存</li><li class=\"ql-align-justify\"><br></li></ul><p class=\"ql-align-justify\">可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式：</p><ul><li class=\"ql-align-justify\">直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。</li><li><br></li><li class=\"ql-align-justify\">回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。</li><li class=\"ql-align-justify\"><br></li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">表分区</span></p><p class=\"ql-align-justify\">MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码</p><p class=\"ql-align-justify\">对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">EXPLAIN PARTITIONS</code>来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：</p><pre class=\"ql-syntax\" spellcheck=\"false\">mysql&gt; explain partitions select count(1) from user_partition where id in (1,2,3,4,5);\n+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+| id | select_type | table &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| partitions | type &nbsp;| possible_keys | key &nbsp; &nbsp; | key_len | ref &nbsp;| rows | Extra &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+| &nbsp;1 | SIMPLE &nbsp; &nbsp; &nbsp;| user_partition | p1,p4 &nbsp; &nbsp; &nbsp;| range | PRIMARY &nbsp; &nbsp; &nbsp; | PRIMARY | 8 &nbsp; &nbsp; &nbsp; | NULL | &nbsp; &nbsp;5 | Using where; Using index |\n+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+1 row in set (0.00 sec)\n</pre><p class=\"ql-align-justify\">分区的好处是：</p><ul><li class=\"ql-align-justify\">可以让单表存储更多的数据</li><li><br></li><li class=\"ql-align-justify\">分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li><li><br></li><li class=\"ql-align-justify\">部分查询能够从查询条件确定只落在少数分区上，速度会很快</li><li><br></li><li class=\"ql-align-justify\">分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备</li><li><br></li><li class=\"ql-align-justify\">可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li><li><br></li><li class=\"ql-align-justify\">可以备份和恢复单个分区</li><li class=\"ql-align-justify\"><br></li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">分区的限制和缺点：</span></p><ul><li class=\"ql-align-justify\">一个表最多只能有1024个分区</li><li><br></li><li class=\"ql-align-justify\">如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li><br></li><li class=\"ql-align-justify\">分区表无法使用外键约束</li><li><br></li><li class=\"ql-align-justify\">NULL值会使分区过滤无效</li><li><br></li><li class=\"ql-align-justify\">所有分区必须使用相同的存储引擎</li><li class=\"ql-align-justify\"><br></li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">分区的类型：</span></p><ul><li class=\"ql-align-justify\">RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li><li><br></li><li class=\"ql-align-justify\">LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li><li><br></li><li class=\"ql-align-justify\">HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li><li><br></li><li class=\"ql-align-justify\">KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li><li class=\"ql-align-justify\"><br></li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">分区适合的场景有：</span></p><ul><li class=\"ql-align-justify\">最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：</li></ul><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">CREATE&nbsp;TABLE&nbsp;members (\n&nbsp;&nbsp;firstname&nbsp;VARCHAR(25)&nbsp;NOT&nbsp;NULL,\n&nbsp;&nbsp;lastname&nbsp;VARCHAR(25)&nbsp;NOT&nbsp;NULL,\n&nbsp;&nbsp;username&nbsp;VARCHAR(16)&nbsp;NOT&nbsp;NULL,\n&nbsp;&nbsp;email&nbsp;VARCHAR(35),\n&nbsp;&nbsp;joined&nbsp;DATE&nbsp;NOT&nbsp;NULL\n)\nPARTITION&nbsp;BY&nbsp;RANGE(&nbsp;YEAR(joined) ) (\n&nbsp;&nbsp;PARTITION&nbsp;p0&nbsp;VALUES&nbsp;LESS&nbsp;THAN&nbsp;(1960),\n&nbsp;&nbsp;PARTITION&nbsp;p1&nbsp;VALUES&nbsp;LESS&nbsp;THAN&nbsp;(1970),\n&nbsp;&nbsp;PARTITION&nbsp;p2&nbsp;VALUES&nbsp;LESS&nbsp;THAN&nbsp;(1980),\n&nbsp;&nbsp;PARTITION&nbsp;p3&nbsp;VALUES&nbsp;LESS&nbsp;THAN&nbsp;(1990),\n&nbsp;&nbsp;PARTITION&nbsp;p4&nbsp;VALUES&nbsp;LESS&nbsp;THAN&nbsp;MAXVALUE\n);\n</pre><p class=\"ql-align-justify\">查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。</p><ul><li class=\"ql-align-justify\">如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存</li></ul><p><br></p><p class=\"ql-align-justify\">另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代</p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">垂直拆分</span></p><p class=\"ql-align-justify\">垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联</p><p class=\"ql-align-justify\">比如原始的用户表是：</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">垂直拆分后是：</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">垂直拆分的优点是：</p><ul><li class=\"ql-align-justify\">可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block 就少)</li><li><br></li><li class=\"ql-align-justify\">可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起</li><li><br></li><li class=\"ql-align-justify\">数据维护简单</li><li class=\"ql-align-justify\"><br></li></ul><p class=\"ql-align-justify\">缺点是：</p><ul><li class=\"ql-align-justify\">主键出现冗余，需要管理冗余列</li><li><br></li><li class=\"ql-align-justify\">会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力</li><li><br></li><li class=\"ql-align-justify\">依然存在单表数据量过大的问题（需要水平拆分）</li><li><br></li><li class=\"ql-align-justify\">事务处理复杂</li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">水平拆分</span></p><h4>概述</h4><p><br></p><p class=\"ql-align-justify\">水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表</p><p class=\"ql-align-justify\">库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决</p><p class=\"ql-align-justify\">前面垂直拆分的用户表如果进行水平拆分，结果是：</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">实际情况中往往会是垂直拆分和水平拆分的结合，即将<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">Users_A_M</code>和<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">Users_N_Z</code>再拆成<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">Users</code>和<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">UserExtras</code>，这样一共四张表</p><p class=\"ql-align-justify\">水平拆分的优点是:</p><ul><li class=\"ql-align-justify\">不存在单库大数据和高并发的性能瓶颈</li><li><br></li><li class=\"ql-align-justify\">应用端改造较少</li><li><br></li><li class=\"ql-align-justify\">提高了系统的稳定性和负载能力</li></ul><p class=\"ql-align-justify\">缺点是：</p><ul><li class=\"ql-align-justify\">分片事务一致性难以解决</li><li><br></li><li class=\"ql-align-justify\">跨节点Join性能差，逻辑复杂</li><li><br></li><li class=\"ql-align-justify\">数据多次扩展难度跟维护量极大</li></ul><h4>分片原则</h4><p><br></p><ul><li class=\"ql-align-justify\">能不分就不分，参考单表优化</li><li><br></li><li class=\"ql-align-justify\">分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量</li><li><br></li><li class=\"ql-align-justify\">分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容</li><li><br></li><li class=\"ql-align-justify\">尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题</li><li><br></li><li class=\"ql-align-justify\">查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。</li><li><br></li><li class=\"ql-align-justify\">通过数据冗余和表分区赖降低跨库Join的可能</li></ul><p class=\"ql-align-justify\">这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p><p class=\"ql-align-justify\">总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。</p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">解决方案</span></p><p class=\"ql-align-justify\">由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">客户端架构</span></p><p class=\"ql-align-justify\">通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现</p><p class=\"ql-align-justify\">这是一个客户端架构的例子：</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现</p><p class=\"ql-align-justify\">客户端架构的优点是：</p><ul><li class=\"ql-align-justify\">应用直连数据库，降低外围系统依赖所带来的宕机风险</li><li><br></li><li class=\"ql-align-justify\">集成成本低，无需额外运维的组件</li></ul><p class=\"ql-align-justify\">缺点是：</p><ul><li class=\"ql-align-justify\">限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心</li><li><br></li><li class=\"ql-align-justify\">将分片逻辑的压力放在应用服务器上，造成额外风险</li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">代理架构</span></p><p class=\"ql-align-justify\">通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件</p><p class=\"ql-align-justify\">这是一个代理架构的例子：</p><p class=\"ql-align-justify\"><br></p><p class=\"ql-align-justify\">代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理</p><p class=\"ql-align-justify\">代理架构的优点是：</p><ul><li class=\"ql-align-justify\">能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强</li><li><br></li><li class=\"ql-align-justify\">对于应用服务器透明且没有增加任何额外负载</li></ul><p class=\"ql-align-justify\">缺点是：</p><ul><li class=\"ql-align-justify\">需部署和运维独立的代理中间件，成本高</li><li><br></li><li class=\"ql-align-justify\">应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险</li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">各方案比较</span></p><p>出品方架构模型支持数据库分库分表读写分离外部依赖是否开源实现语言支持语言最后更新Github星数MySQL FabricMySQL官方代理架构MySQL有有有无是python无限制4个月前35Cobar阿里巴巴代理架构MySQL有无无无是Java无限制两年前1287Cobar Client阿里巴巴客户端架构MySQL有无无无是JavaJava三年前344TDDL淘宝客户端架构无限制有有有Diamond只开源部分JavaJava未知519Atlas奇虎360代理架构MySQL有有有无是C无限制10个月前1941Heisenberg百度熊照代理架构MySQL有有有无是Java无限制2个月前197TribeDB个人代理架构MySQL有有有无是NodeJS无限制3个月前126ShardingJDBC当当客户端架构MySQL有有有无是JavaJava当天1144Shark个人客户端架构MySQL有有无无是JavaJava两天前84KingShard个人代理架构MySQL有有有无是Golang无限制两天前1836OneProxy平民软件代理架构MySQL有有有无否未知无限制未知未知MyCat社区代理架构MySQL有有有无是Java无限制两天前1270VitessYoutube代理架构MySQL有有有无是Golang无限制当天3636Mixer个人代理架构MySQL有有无无是Golang无限制9个月前472JetPantsTumblr客户端架构MySQL有有无无是RubyRuby10个月前957HibernateShardHibernate客户端架构无限制有有无无是JavaJava4年前57MybatisShardMakerSoft客户端架构无限制有有无无是JavaJava11个月前119GizzardTwitter代理架构无限制有有无无是Java无限制3年前2087</p><p class=\"ql-align-justify\">如此多的方案，如何进行选择？可以按以下思路来考虑：</p><ol><li class=\"ql-align-justify\">确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构</li><li><br></li><li class=\"ql-align-justify\">具体功能是否满足，比如需要跨节点<code style=\"background-color: rgb(249, 242, 244); color: rgb(199, 37, 78);\">ORDER BY</code>，那么支持该功能的优先考虑</li><li><br></li><li class=\"ql-align-justify\">不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持</li><li><br></li><li class=\"ql-align-justify\">最好按大公司-&gt;社区-&gt;小公司-&gt;个人这样的出品方顺序来选择</li><li><br></li><li class=\"ql-align-justify\">选择口碑较好的，比如github星数、使用者数量质量和使用者反馈</li><li><br></li><li class=\"ql-align-justify\">开源的优先，往往项目有特殊需求可能需要改动源代码</li></ol><p class=\"ql-align-justify\">按照上述思路，推荐以下选择：</p><ul><li class=\"ql-align-justify\">客户端架构：ShardingJDBC</li><li><br></li><li class=\"ql-align-justify\">代理架构：MyCat或者Atlas</li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">兼容MySQL且可水平扩展的数据库</span></p><p class=\"ql-align-justify\">目前也有一些开源数据库兼容MySQL协议，如：</p><ul><li class=\"ql-align-justify\">TiDB</li><li><br></li><li class=\"ql-align-justify\">Cubrid</li></ul><p class=\"ql-align-justify\">但其工业品质和MySQL尚有差距，且需要较大的运维投入，如果想将原始的MySQL迁移到可水平扩展的新数据库中，可以考虑一些云数据库：</p><ul><li class=\"ql-align-justify\">阿里云PetaData</li><li><br></li><li class=\"ql-align-justify\">阿里云OceanBase</li><li><br></li><li class=\"ql-align-justify\">腾讯云DCDB</li></ul><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(51, 51, 51);\">NoSQL</span></p><p class=\"ql-align-justify\">在MySQL上做Sharding是一种戴着镣铐的跳舞，事实上很多大表本身对MySQL这种RDBMS的需求并不大，并不要求ACID，可以考虑将这些表迁移到NoSQL，彻底解决水平扩展问题，例如：</p><ul><li class=\"ql-align-justify\">日志类、监控类、统计类数据</li><li><br></li><li class=\"ql-align-justify\">非结构化或弱结构化数据</li><li><br></li><li class=\"ql-align-justify\">对事务要求不强，且无太多关联操作的数据</li></ul><p><br></p>', '1', '1', '登记中', '1');
INSERT INTO `tb_paper` VALUES ('34', 'Java 危矣！统治地位已不复存在？', '2018-06-15 09:36:16', null, '<p class=\"ql-align-justify\">有云天下，有人江湖，编程的江湖亦是如此。编程的江湖上也是豪强诸起，门派众多，各足鼎立。虽说没有什么武林大会，也没有华山论剑，但是编程的江湖，也不比他们差，亦是精彩纷呈。</p><p class=\"ql-align-justify\">在比较的老派和老牌的门派当中，C 门派最为受人尊敬，辈分较高，C++ 门派都属于 C 门派之列，后来由于其独有的气势和特点， C 门派中的 C 和 C++ ，都有一种华山门派剑宗和气宗的意思，但是毕竟同气连枝，在面对共同敌人的时候，还是师兄弟的关系。</p><p class=\"ql-align-justify\">而 Java 门派其弟子更是众多，自诞生之初，尤其善于后端技术，以其精湛稳定的技术持续火爆了近20年，在江湖上也有不减之势。</p><p class=\"ql-align-justify\">在武林排行前十的门派中， PHP 也是一个强势的存在，对它的赞美和推崇亦是赞不绝口，江湖中毕竟传言：它才是世界上最好的门派。要论天下武功，唯有 PHP 。作为后起之秀，吸收了Java 和 C 以及 Perl 等技术特点，很快蚕食了和席卷了 Web 端，让 Java 在 Web 端损失惨重。</p><p class=\"ql-align-justify\">在此期间，Python ，Ruby ，JavaScript 等门派都在涌动的暗流中暗自发力，期待能有一天，与武林中扬名立万，一统江湖。</p><p class=\"ql-align-justify\">这都是在互联网时代上叱咤风云的门派了，C 门派在其速度上是其他门派所不及的，可谓稳准狠，软硬通吃，而其他门派都是吃软不吃硬，随着时代的发展，到了移动互联网时代，Java 竟然在 Android 地界上开辟了一个新天地。</p><p class=\"ql-align-justify\">随着历史进程的演进，谁先站住终端平台，谁就有先发制人的优势，不知不觉就在被人追赶超越的时候，Java 在 Android 的地界上火了，已然成为了燎原之势。一时间让其他门派望其项背，长期占据琅琊榜武林门派排行的第一名，其气势犹如武林盟主一般。殊不知，在更换了掌门以后得 Java，作为掌门人的 Oracle 喜欢使用阴招，到处往其他门派中送出间谍和卧底，让其他门派有点措手不及，使用武林名声要挟其他门派，说其他门派盗其武林绝学，索要各种损失费。</p><p class=\"ql-align-justify\">在半梦半醒中，在洋洋得意时，JavaScript 忽然来到了Java 门派这里，送上了拜贴，求见 Java 。</p><p class=\"ql-align-justify\">JavaScript 行色匆匆，慌慌张张的见到Java：“Java 师兄，小弟来找你有急事求见。”</p><p class=\"ql-align-justify\">“你 TMD 的跟谁攀关系呢？谁是你师兄，你从哪里论的？我跟你没毛关系。什么事？有话快说，有屁快放。”Java 一脸孤傲且有点生气的说。</p><p class=\"ql-align-justify\">JavaScript 心里暗想：“好吧，我不跟你计较，自己倒霉了，还不知道，傲娇个屁啊！”</p><p class=\"ql-align-justify\">“你知道吗？据从谷歌那里传出来的消息说，在功力较高的弟子中有 35% 的人在Android 地界都投入到了 Kotlin 门派，而且这个数字正在逐月递增，越来越多的兄弟要加入了。你损失惨重啊！”JavaScript 暗自庆幸且看笑话的说。</p><p class=\"ql-align-justify\">Java：“我知道了，我门派弟子都投向其他门派还不知道吗？用你来说，这也不能怪我啊，自从换了掌门，在于谷歌打口水仗以来，看似胜了，其实又败了，我也无能为力。你小子也不是什么好东西，你来看我笑话的吧？”</p><p class=\"ql-align-justify\">JavaScript：“不如咱们开个武林大会吧，召集众门派，划清地盘，分清界限，最好井水不犯河水。”</p><p class=\"ql-align-justify\">Java心里暗想：“划清地盘，分清界限？就尼玛 JavaScript 划不清楚界限，分不清楚地盘，自移动互联网时代以来，你野心勃勃，到处抢生意。肚子里肯定没什么好事，一肚子坏水，我要看看你到底想干嘛？”</p><p class=\"ql-align-justify\">“好，那咱就召开，由 C 门派主持会议，由我光发英雄贴，你负责整个大会的安排，具体你操作。”Java试探性的说。</p><p class=\"ql-align-justify\">JavaScript：“好，马上干。一溜烟高高兴兴的马上去行动了。”</p><p class=\"ql-align-justify\">武林大会在 JavaScript 的安排下，如期举行，看在 C 和 Java 的面上确实来了不少门派。C 老祖出来主持会议，说：“今天召集大家来，是为了我们江湖和谐稳定，不要再各自为战，造成内耗。”</p><p class=\"ql-align-justify\">JavaScript 说：“C 老哥说的对啊，我们要团结，要合作，不要互相抢占地盘。我们 JavaScript 门派一向都是主张合作，在各领域合作，互利共赢。不管是前端，还是后台，各项方面，只要需要，我们都可以合作，因为哥们活全。”</p><p class=\"ql-align-justify\">“卧槽，原来召开大会的目的是这样啊！JavaScript 想暗度陈仓，通力合作，一统江湖啊！”Java内心想。</p><p class=\"ql-align-justify\">Python：“通力合作？你们 JavaScript 确实活全。但是不精通，想合作行，先把你师弟 Node.js 从后端撤出再说。现在是什么时代？人工智能时代，哥们怕你们？”</p><p class=\"ql-align-justify\">\"PHP，你有什么要说的？\"C 老祖问。</p><p class=\"ql-align-justify\">\"我没什么要说的，我们很专注，我们有自己的能力和业务，作为江湖上传闻最好的门派，我们一向低调。我们都行。\"PHP 说。</p><p class=\"ql-align-justify\">OC 说：“我想静静，swift 一出，我家里都快揭不开锅了，不是亲生的毕竟不行啊！”</p><p class=\"ql-align-justify\">Java 这时频频点头。</p><p class=\"ql-align-justify\">kotlin：“对啊，我虽然不是亲生，胜似亲生，但是毕竟官方首席推荐了，我还是比较幸运的，对吧，Java 老哥？”</p><p class=\"ql-align-justify\">Java：“你牛逼，你厉害行了吧？没有我和 JavaScript 的支持，你屁也不是。在我们的环境下生存，还抢我们的饭碗。”</p><p class=\"ql-align-justify\">JavaScript：“大家不要吵嘛，咱们目的是合作，只要能做生意，挣钱，都好说。咱们要不选个盟主？用于调节纠纷和合作。”我感觉选择个活全的当盟主，有利于领导，毕竟都知道各处的困难嘛！</p><p class=\"ql-align-justify\">PHP：“论辈分，论资历，论能力，论功力，当然……当然不是我，我推荐 C 老哥。”</p><p class=\"ql-align-justify\">C老祖：“不敢当，不敢当。其实内心想，这破盟主有啥好当的，乱炖。”</p><p class=\"ql-align-justify\">Java：“要论最近20年的流行度和统治力的话，我应该当仁不让。”</p><p class=\"ql-align-justify\">Python：“且，你没看最近的琅琊榜武林排行吗？把榜单拿来瞧一瞧，谁是第一？在人工智能时代，流行度，我第一，排行榜，我第一。你没落了，心里没点逼数吗？”</p><p class=\"ql-align-justify\">Go：“go,go,go，我走了，太吵人了。”Go 暗想：“这这些年都说要推翻java的统治地位，也没见他被推翻，作为后起之秀的我，不想这些，只想努力做好自己。”在大会上一言没发的go走了。</p><p class=\"ql-align-justify\">其他门派各自不服，吵声越来越大，而 JavaScript 在暗喜，我的目的达到了，吵个你死我活，我渔翁得利，等你们两败俱伤，我好一统江湖。</p><p class=\"ql-align-justify\">总结，以上内容纯属虚构，如有雷同，没错是我写的。关于Java 危矣的言论，我们就让Java自己现身说法。</p><p class=\"ql-align-justify\">Java ：<strong>好了，就让他们吵吧，我来说说我自己的观点，不可否认kotlin在蚕食我在安卓端的市场，它有它的优势，我也有我的特点，而且kotlin现在总体来说确实不错，但是不能跟我20多年的稳定和积累所比。而关于大数据，人工智能方面，Python 确实增长很快，但是等你真懂了大数据和人工智能，你都不会去想你用的是 Python 还是 Java 了，在纠结语言的时候，说明你还处在初级阶段。另外，我在自诞生以来，就没错过互联网上的任何一个热点，所以才会这么持久。JavaScript 不就是因为我 Java 太火太流行，为了蹭我的热点才起这跟我有关系的名字吗？其实一点关系没有。当程序员语言只是工具，不要太在乎用什么工具，应该在乎如何用好工具，如何使用工具。</strong></p><p><br></p>', '1', '2', '待审核', '2');

-- ----------------------------
-- Table structure for tb_paper_type
-- ----------------------------
DROP TABLE IF EXISTS `tb_paper_type`;
CREATE TABLE `tb_paper_type` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(40) CHARACTER SET utf8 NOT NULL,
  `userid` bigint(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of tb_paper_type
-- ----------------------------
INSERT INTO `tb_paper_type` VALUES ('1', '数据库', '1');
INSERT INTO `tb_paper_type` VALUES ('2', 'Java', '1');
INSERT INTO `tb_paper_type` VALUES ('3', '网络安全', '1');
INSERT INTO `tb_paper_type` VALUES ('4', '爬虫', '1');

-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
DROP TABLE IF EXISTS `tb_user`;
CREATE TABLE `tb_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL,
  `type` varchar(20) DEFAULT NULL,
  `iphone` varchar(30) DEFAULT NULL,
  `password` varchar(30) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES ('1', 'fwe', '1', '18072834696', '123456');
INSERT INTO `tb_user` VALUES ('2', 'zhou', '2', '13587396989', '123456');
